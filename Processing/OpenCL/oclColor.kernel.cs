//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.34011
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

namespace System.OpenCL {
  /*public class clRGBtoHSV : OpenCL.Net.Extensions.KernelWrapperBase {
        
        public clRGBtoHSV(OpenCL.Net.Context context) : 
                base(context) {
        }
        
        protected override string KernelPath {
            get {
                return System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "OpenCL\\library\\oclColor.cl");
            }
        }
        
        protected override string OriginalKernelPath {
            get {
                return "D:\\Dropbox\\_Bachelor-Arbeit\\Code\\ImageProcessingCore\\OpenCL\\library\\oclColor.cl";
            }
        }
        
        protected override string KernelSource {
            get {
                return "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\nfloat minComp(float4 v)\n{\n    float t = (v.x<v.y) ? v" +
                    ".x : v.y;\n    t = (t<v.z) ? t : v.z;\n    return t;\n}\n\nfloat maxComp(float4 v)\n{\n" +
                    "    float t = (v.x>v.y) ? v.x : v.y;\n    t = (t>v.z) ? t : v.z;\n    return t;\n}\n" +
                    "\n\r\n\r\n\r\n\nfloat4 RGBtoHSV(float4 RGB)\n{\n    float4 HSV = (float4)0.0f;\n    float m" +
                    "inVal = minComp(RGB);\n    float maxVal = maxComp(RGB);\n    float delta = maxVal " +
                    "- minVal;           \n    if (delta != 0.0f) \n    {                   \n        fl" +
                    "oat4 delRGB = ((((float4)(maxVal) - RGB)/6.0f) + (delta/2.0f))/delta;\n\n        H" +
                    "SV.y = delta / maxVal;\n\n        if ( RGB.x == maxVal ) \n            HSV.x = delR" +
                    "GB.z - delRGB.y;\n        else if (RGB.y == maxVal) \n            HSV.x = (1.0/3.0" +
                    ") + delRGB.x - delRGB.z;\n        else if (RGB.z == maxVal) \n            HSV.x = " +
                    "(2.0/3.0) + delRGB.y - delRGB.x;\n\n        if (HSV.x < 0.0f)  \n            HSV.x " +
                    "+= 1.0f;\n        if (HSV.x > 1.0f)\n            HSV.x -= 1.0f;\n    }\n    HSV.z = " +
                    "maxVal;\n    HSV.w = RGB.w;\n    return (HSV);\n}\n\nfloat4 HSVtoRGB(float4 HSV)\n{\n  " +
                    "  float4 RGB = (float4)0.0f;\n    if (HSV.z != 0.0f) \n    {\n        float var_h =" +
                    " HSV.x * 6.0f;\n        float var_i = floor(var_h-0.000001f);   \n        float va" +
                    "r_1 = HSV.z * (1.0f - HSV.y);\n        float var_2 = HSV.z * (1.0f - HSV.y * (var" +
                    "_h-var_i));\n        float var_3 = HSV.z * (1.0f - HSV.y * (1-(var_h-var_i)));\n  " +
                    "      switch((int)(var_i))\n        {\n            case 0: RGB = (float4)(HSV.z, v" +
                    "ar_3, var_1, HSV.w); break;\n            case 1: RGB = (float4)(var_2, HSV.z, var" +
                    "_1, HSV.w); break;\n            case 2: RGB = (float4)(var_1, HSV.z, var_3, HSV.w" +
                    "); break;\n            case 3: RGB = (float4)(var_1, var_2, HSV.z, HSV.w); break;" +
                    "\n            case 4: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        " +
                    "    default: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        }\n    }\n" +
                    "    RGB.w = HSV.w;\n    return (RGB);\n}\n\n__kernel void clRGBtoHSV(__read_only ima" +
                    "ge2d_t srce,__write_only image2d_t dest)\n{\n    const sampler_t sampler = CLK_NOR" +
                    "MALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_g" +
                    "lobal_id(0);\n    int y = get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write" +
                    "_imagef(dest, idx, RGBtoHSV(read_imagef(srce, sampler, idx)));\n}\n\n__kernel void " +
                    "clHSVtoRGB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const s" +
                    "ampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRES" +
                    "S_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 id" +
                    "x = (int2)(x,y);\n    write_imagef(dest, idx, HSVtoRGB(read_imagef(srce, sampler," +
                    " idx)));\n}\n\n\n\r\n\r\n\r\n\nfloat4 RGBtoXYZ(float4 RGB)\n{\n    float r = (RGB.x > 0.04045" +
                    "f)? pow((RGB.x + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.x/12.92f) ;\n    float g = (R" +
                    "GB.y > 0.04045f)? pow((RGB.y + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.y/12.92f) ;\n  " +
                    "  float b = (RGB.z > 0.04045f)? pow((RGB.z + 0.055f)/(1 + 0.055f), 2.2f) : (RGB." +
                    "z/12.92f) ;\n\n    return (float4)((r*0.4124f + g*0.3576f + b*0.1805f),\n          " +
                    "          (r*0.2126f + g*0.7152f + b*0.0722f),\n                    (r*0.0193f + " +
                    "g*0.1192f + b*0.9505f),\n                    RGB.w\n                  );\n}\n\nfloat4" +
                    " XYZtoRGB(float4 XYZ)\n{\n    float4 val;\n    val.x =  XYZ.x*3.2410f - XYZ.y*1.537" +
                    "4f - XYZ.z*0.4986f;\n    val.y = -XYZ.x*0.9692f + XYZ.y*1.8760f - XYZ.z*0.0416f;\n" +
                    "    val.z =  XYZ.x*0.0556f - XYZ.y*0.2040f + XYZ.z*1.0570f;\n\n    val.x = (val.x<" +
                    "=0.0031308f)? 12.92f*val.x : (1.0f+0.055f)* pow(val.x, (1.0f/2.4f)) - 0.055f;\n  " +
                    "  val.y = (val.y<=0.0031308f)? 12.92f*val.y : (1.0f+0.055f)* pow(val.y, (1.0f/2." +
                    "4f)) - 0.055f;\n    val.z = (val.z<=0.0031308f)? 12.92f*val.z : (1.0f+0.055f)* po" +
                    "w(val.z, (1.0f/2.4f)) - 0.055f;\n\n    val.w = XYZ.w;\n    return val;\n}\n\n__kernel " +
                    "void clRGBtoXYZ(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    co" +
                    "nst sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_A" +
                    "DDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    in" +
                    "t2 idx = (int2)(x,y);\n    write_imagef(dest, idx, RGBtoXYZ(read_imagef(srce, sam" +
                    "pler, idx)));\n}\n\n__kernel void clXYZtoRGB(__read_only image2d_t srce,__write_onl" +
                    "y image2d_t dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | " +
                    "CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y " +
                    "= get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, XYZt" +
                    "oRGB(read_imagef(srce, sampler, idx)));\n}\n\n\r\n\r\n\r\n\n\nfloat Ffor(float t)\n{\n    ret" +
                    "urn ((t > 0.008856f)? pow(t, (1.0f/3.0f)) : (7.787f*t + 16.0f/116.0f));\n}\n\nfloat" +
                    "4 RGBtoLAB(float4 RGB)\n{\n    const float4 D65 = (float4)(0.9505f, 1.0f, 1.0890f," +
                    " 0.0f);\n\n    float4 XYZ = RGBtoXYZ(RGB);\n\n    float4 LAB;\n    LAB.x = 116.0f *  " +
                    "Ffor(XYZ.y/D65.y) -16.0f;\n    LAB.y = 500.0f * (Ffor(XYZ.x/D65.x) - Ffor(XYZ.y/D" +
                    "65.y));\n    LAB.z = 200.0f * (Ffor(XYZ.y/D65.y) - Ffor(XYZ.z/D65.z));\n    LAB.w " +
                    "= XYZ.w;\n    return LAB;\n}\n\nfloat4 LABtoRGB(float4 LAB)\n{\n    const float4 D65 =" +
                    " (float4)(0.9505, 1.0, 1.0890, 0.0);\n\n    float fy = (LAB.x+16.0f)/116.0f;\n    f" +
                    "loat fx = fy + (LAB.y/500.0f);\n    float fz = fy - (LAB.z/200.0f);\n\n    float de" +
                    "lta = 6.0/29.0;\n    float4 XYZ = (float4)(\n                (fx > delta)? D65.x *" +
                    " (fx*fx*fx) : (fx - 16.0f/116.0f)*3*(delta*delta)*D65.x,\n                (fy > d" +
                    "elta)? D65.y * (fy*fy*fy) : (fy - 16.0f/116.0f)*3*(delta*delta)*D65.y,\n         " +
                    "       (fz > delta)? D65.z * (fz*fz*fz) : (fz - 16.0f/116.0f)*3*(delta*delta)*D6" +
                    "5.z,\n                 LAB.w);\n\n    return XYZtoRGB(XYZ);\n}\n\n__kernel void clRGBt" +
                    "oLAB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const sampler" +
                    "_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAM" +
                    "P;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 idx = (i" +
                    "nt2)(x,y);\n    write_imagef(dest, idx, RGBtoLAB(read_imagef(srce, sampler, idx))" +
                    ");\n}\n\n__kernel void clLABtoRGB(__read_only image2d_t srce,__write_only image2d_t" +
                    " dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_" +
                    "NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_globa" +
                    "l_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, LABtoRGB(read_i" +
                    "magef(srce, sampler, idx)));\n}\n\n\n";
            }
        }
        
        protected override string KernelName {
            get {
                return "clRGBtoHSV";
            }
        }
        
        private OpenCL.Net.Event run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1 = 0, uint globalWorkSize2 = 0, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 0, srce);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 1, dest);
            OpenCL.Net.Event ev;
            OpenCL.Net.ErrorCode err;
            err = OpenCL.Net.Cl.EnqueueNDRangeKernel(commandQueue, this.Kernel, base.GetWorkDimension(globalWorkSize0, globalWorkSize1, globalWorkSize2), null, base.GetWorkSizes(globalWorkSize0, globalWorkSize1, globalWorkSize2), base.GetWorkSizes(localWorkSize0, localWorkSize1, localWorkSize2), ((uint)(waitFor.Length)), waitFor.Length == 0 ? null : waitFor, out ev);
            OpenCL.Net.Cl.Check(err);
            return ev;
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
        }
    }
    
    public class clRGBtoXYZ : OpenCL.Net.Extensions.KernelWrapperBase {
        
        public clRGBtoXYZ(OpenCL.Net.Context context) : 
                base(context) {
        }
        
        protected override string KernelPath {
            get {
                return System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "OpenCL\\library\\oclColor.cl");
            }
        }
        
        protected override string OriginalKernelPath {
            get {
                return "D:\\Dropbox\\_Bachelor-Arbeit\\Code\\ImageProcessingCore\\OpenCL\\library\\oclColor.cl";
            }
        }
        
        protected override string KernelSource {
            get {
                return "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\nfloat minComp(float4 v)\n{\n    float t = (v.x<v.y) ? v" +
                    ".x : v.y;\n    t = (t<v.z) ? t : v.z;\n    return t;\n}\n\nfloat maxComp(float4 v)\n{\n" +
                    "    float t = (v.x>v.y) ? v.x : v.y;\n    t = (t>v.z) ? t : v.z;\n    return t;\n}\n" +
                    "\n\r\n\r\n\r\n\nfloat4 RGBtoHSV(float4 RGB)\n{\n    float4 HSV = (float4)0.0f;\n    float m" +
                    "inVal = minComp(RGB);\n    float maxVal = maxComp(RGB);\n    float delta = maxVal " +
                    "- minVal;           \n    if (delta != 0.0f) \n    {                   \n        fl" +
                    "oat4 delRGB = ((((float4)(maxVal) - RGB)/6.0f) + (delta/2.0f))/delta;\n\n        H" +
                    "SV.y = delta / maxVal;\n\n        if ( RGB.x == maxVal ) \n            HSV.x = delR" +
                    "GB.z - delRGB.y;\n        else if (RGB.y == maxVal) \n            HSV.x = (1.0/3.0" +
                    ") + delRGB.x - delRGB.z;\n        else if (RGB.z == maxVal) \n            HSV.x = " +
                    "(2.0/3.0) + delRGB.y - delRGB.x;\n\n        if (HSV.x < 0.0f)  \n            HSV.x " +
                    "+= 1.0f;\n        if (HSV.x > 1.0f)\n            HSV.x -= 1.0f;\n    }\n    HSV.z = " +
                    "maxVal;\n    HSV.w = RGB.w;\n    return (HSV);\n}\n\nfloat4 HSVtoRGB(float4 HSV)\n{\n  " +
                    "  float4 RGB = (float4)0.0f;\n    if (HSV.z != 0.0f) \n    {\n        float var_h =" +
                    " HSV.x * 6.0f;\n        float var_i = floor(var_h-0.000001f);   \n        float va" +
                    "r_1 = HSV.z * (1.0f - HSV.y);\n        float var_2 = HSV.z * (1.0f - HSV.y * (var" +
                    "_h-var_i));\n        float var_3 = HSV.z * (1.0f - HSV.y * (1-(var_h-var_i)));\n  " +
                    "      switch((int)(var_i))\n        {\n            case 0: RGB = (float4)(HSV.z, v" +
                    "ar_3, var_1, HSV.w); break;\n            case 1: RGB = (float4)(var_2, HSV.z, var" +
                    "_1, HSV.w); break;\n            case 2: RGB = (float4)(var_1, HSV.z, var_3, HSV.w" +
                    "); break;\n            case 3: RGB = (float4)(var_1, var_2, HSV.z, HSV.w); break;" +
                    "\n            case 4: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        " +
                    "    default: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        }\n    }\n" +
                    "    RGB.w = HSV.w;\n    return (RGB);\n}\n\n__kernel void clRGBtoHSV(__read_only ima" +
                    "ge2d_t srce,__write_only image2d_t dest)\n{\n    const sampler_t sampler = CLK_NOR" +
                    "MALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_g" +
                    "lobal_id(0);\n    int y = get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write" +
                    "_imagef(dest, idx, RGBtoHSV(read_imagef(srce, sampler, idx)));\n}\n\n__kernel void " +
                    "clHSVtoRGB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const s" +
                    "ampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRES" +
                    "S_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 id" +
                    "x = (int2)(x,y);\n    write_imagef(dest, idx, HSVtoRGB(read_imagef(srce, sampler," +
                    " idx)));\n}\n\n\n\r\n\r\n\r\n\nfloat4 RGBtoXYZ(float4 RGB)\n{\n    float r = (RGB.x > 0.04045" +
                    "f)? pow((RGB.x + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.x/12.92f) ;\n    float g = (R" +
                    "GB.y > 0.04045f)? pow((RGB.y + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.y/12.92f) ;\n  " +
                    "  float b = (RGB.z > 0.04045f)? pow((RGB.z + 0.055f)/(1 + 0.055f), 2.2f) : (RGB." +
                    "z/12.92f) ;\n\n    return (float4)((r*0.4124f + g*0.3576f + b*0.1805f),\n          " +
                    "          (r*0.2126f + g*0.7152f + b*0.0722f),\n                    (r*0.0193f + " +
                    "g*0.1192f + b*0.9505f),\n                    RGB.w\n                  );\n}\n\nfloat4" +
                    " XYZtoRGB(float4 XYZ)\n{\n    float4 val;\n    val.x =  XYZ.x*3.2410f - XYZ.y*1.537" +
                    "4f - XYZ.z*0.4986f;\n    val.y = -XYZ.x*0.9692f + XYZ.y*1.8760f - XYZ.z*0.0416f;\n" +
                    "    val.z =  XYZ.x*0.0556f - XYZ.y*0.2040f + XYZ.z*1.0570f;\n\n    val.x = (val.x<" +
                    "=0.0031308f)? 12.92f*val.x : (1.0f+0.055f)* pow(val.x, (1.0f/2.4f)) - 0.055f;\n  " +
                    "  val.y = (val.y<=0.0031308f)? 12.92f*val.y : (1.0f+0.055f)* pow(val.y, (1.0f/2." +
                    "4f)) - 0.055f;\n    val.z = (val.z<=0.0031308f)? 12.92f*val.z : (1.0f+0.055f)* po" +
                    "w(val.z, (1.0f/2.4f)) - 0.055f;\n\n    val.w = XYZ.w;\n    return val;\n}\n\n__kernel " +
                    "void clRGBtoXYZ(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    co" +
                    "nst sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_A" +
                    "DDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    in" +
                    "t2 idx = (int2)(x,y);\n    write_imagef(dest, idx, RGBtoXYZ(read_imagef(srce, sam" +
                    "pler, idx)));\n}\n\n__kernel void clXYZtoRGB(__read_only image2d_t srce,__write_onl" +
                    "y image2d_t dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | " +
                    "CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y " +
                    "= get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, XYZt" +
                    "oRGB(read_imagef(srce, sampler, idx)));\n}\n\n\r\n\r\n\r\n\n\nfloat Ffor(float t)\n{\n    ret" +
                    "urn ((t > 0.008856f)? pow(t, (1.0f/3.0f)) : (7.787f*t + 16.0f/116.0f));\n}\n\nfloat" +
                    "4 RGBtoLAB(float4 RGB)\n{\n    const float4 D65 = (float4)(0.9505f, 1.0f, 1.0890f," +
                    " 0.0f);\n\n    float4 XYZ = RGBtoXYZ(RGB);\n\n    float4 LAB;\n    LAB.x = 116.0f *  " +
                    "Ffor(XYZ.y/D65.y) -16.0f;\n    LAB.y = 500.0f * (Ffor(XYZ.x/D65.x) - Ffor(XYZ.y/D" +
                    "65.y));\n    LAB.z = 200.0f * (Ffor(XYZ.y/D65.y) - Ffor(XYZ.z/D65.z));\n    LAB.w " +
                    "= XYZ.w;\n    return LAB;\n}\n\nfloat4 LABtoRGB(float4 LAB)\n{\n    const float4 D65 =" +
                    " (float4)(0.9505, 1.0, 1.0890, 0.0);\n\n    float fy = (LAB.x+16.0f)/116.0f;\n    f" +
                    "loat fx = fy + (LAB.y/500.0f);\n    float fz = fy - (LAB.z/200.0f);\n\n    float de" +
                    "lta = 6.0/29.0;\n    float4 XYZ = (float4)(\n                (fx > delta)? D65.x *" +
                    " (fx*fx*fx) : (fx - 16.0f/116.0f)*3*(delta*delta)*D65.x,\n                (fy > d" +
                    "elta)? D65.y * (fy*fy*fy) : (fy - 16.0f/116.0f)*3*(delta*delta)*D65.y,\n         " +
                    "       (fz > delta)? D65.z * (fz*fz*fz) : (fz - 16.0f/116.0f)*3*(delta*delta)*D6" +
                    "5.z,\n                 LAB.w);\n\n    return XYZtoRGB(XYZ);\n}\n\n__kernel void clRGBt" +
                    "oLAB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const sampler" +
                    "_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAM" +
                    "P;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 idx = (i" +
                    "nt2)(x,y);\n    write_imagef(dest, idx, RGBtoLAB(read_imagef(srce, sampler, idx))" +
                    ");\n}\n\n__kernel void clLABtoRGB(__read_only image2d_t srce,__write_only image2d_t" +
                    " dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_" +
                    "NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_globa" +
                    "l_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, LABtoRGB(read_i" +
                    "magef(srce, sampler, idx)));\n}\n\n\n";
            }
        }
        
        protected override string KernelName {
            get {
                return "clRGBtoXYZ";
            }
        }
        
        private OpenCL.Net.Event run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1 = 0, uint globalWorkSize2 = 0, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 0, srce);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 1, dest);
            OpenCL.Net.Event ev;
            OpenCL.Net.ErrorCode err;
            err = OpenCL.Net.Cl.EnqueueNDRangeKernel(commandQueue, this.Kernel, base.GetWorkDimension(globalWorkSize0, globalWorkSize1, globalWorkSize2), null, base.GetWorkSizes(globalWorkSize0, globalWorkSize1, globalWorkSize2), base.GetWorkSizes(localWorkSize0, localWorkSize1, localWorkSize2), ((uint)(waitFor.Length)), waitFor.Length == 0 ? null : waitFor, out ev);
            OpenCL.Net.Cl.Check(err);
            return ev;
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
        }
    }
    
    public class clRGBtoLAB : OpenCL.Net.Extensions.KernelWrapperBase {
        
        public clRGBtoLAB(OpenCL.Net.Context context) : 
                base(context) {
        }
        
        protected override string KernelPath {
            get {
                return System.IO.Path.Combine(System.AppDomain.CurrentDomain.BaseDirectory, "OpenCL\\library\\oclColor.cl");
            }
        }
        
        protected override string OriginalKernelPath {
            get {
                return "D:\\Dropbox\\_Bachelor-Arbeit\\Code\\ImageProcessingCore\\OpenCL\\library\\oclColor.cl";
            }
        }
        
        protected override string KernelSource {
            get {
                return "\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\nfloat minComp(float4 v)\n{\n    float t = (v.x<v.y) ? v" +
                    ".x : v.y;\n    t = (t<v.z) ? t : v.z;\n    return t;\n}\n\nfloat maxComp(float4 v)\n{\n" +
                    "    float t = (v.x>v.y) ? v.x : v.y;\n    t = (t>v.z) ? t : v.z;\n    return t;\n}\n" +
                    "\n\r\n\r\n\r\n\nfloat4 RGBtoHSV(float4 RGB)\n{\n    float4 HSV = (float4)0.0f;\n    float m" +
                    "inVal = minComp(RGB);\n    float maxVal = maxComp(RGB);\n    float delta = maxVal " +
                    "- minVal;           \n    if (delta != 0.0f) \n    {                   \n        fl" +
                    "oat4 delRGB = ((((float4)(maxVal) - RGB)/6.0f) + (delta/2.0f))/delta;\n\n        H" +
                    "SV.y = delta / maxVal;\n\n        if ( RGB.x == maxVal ) \n            HSV.x = delR" +
                    "GB.z - delRGB.y;\n        else if (RGB.y == maxVal) \n            HSV.x = (1.0/3.0" +
                    ") + delRGB.x - delRGB.z;\n        else if (RGB.z == maxVal) \n            HSV.x = " +
                    "(2.0/3.0) + delRGB.y - delRGB.x;\n\n        if (HSV.x < 0.0f)  \n            HSV.x " +
                    "+= 1.0f;\n        if (HSV.x > 1.0f)\n            HSV.x -= 1.0f;\n    }\n    HSV.z = " +
                    "maxVal;\n    HSV.w = RGB.w;\n    return (HSV);\n}\n\nfloat4 HSVtoRGB(float4 HSV)\n{\n  " +
                    "  float4 RGB = (float4)0.0f;\n    if (HSV.z != 0.0f) \n    {\n        float var_h =" +
                    " HSV.x * 6.0f;\n        float var_i = floor(var_h-0.000001f);   \n        float va" +
                    "r_1 = HSV.z * (1.0f - HSV.y);\n        float var_2 = HSV.z * (1.0f - HSV.y * (var" +
                    "_h-var_i));\n        float var_3 = HSV.z * (1.0f - HSV.y * (1-(var_h-var_i)));\n  " +
                    "      switch((int)(var_i))\n        {\n            case 0: RGB = (float4)(HSV.z, v" +
                    "ar_3, var_1, HSV.w); break;\n            case 1: RGB = (float4)(var_2, HSV.z, var" +
                    "_1, HSV.w); break;\n            case 2: RGB = (float4)(var_1, HSV.z, var_3, HSV.w" +
                    "); break;\n            case 3: RGB = (float4)(var_1, var_2, HSV.z, HSV.w); break;" +
                    "\n            case 4: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        " +
                    "    default: RGB = (float4)(HSV.z, var_1, var_2, HSV.w); break;\n        }\n    }\n" +
                    "    RGB.w = HSV.w;\n    return (RGB);\n}\n\n__kernel void clRGBtoHSV(__read_only ima" +
                    "ge2d_t srce,__write_only image2d_t dest)\n{\n    const sampler_t sampler = CLK_NOR" +
                    "MALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_g" +
                    "lobal_id(0);\n    int y = get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write" +
                    "_imagef(dest, idx, RGBtoHSV(read_imagef(srce, sampler, idx)));\n}\n\n__kernel void " +
                    "clHSVtoRGB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const s" +
                    "ampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRES" +
                    "S_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 id" +
                    "x = (int2)(x,y);\n    write_imagef(dest, idx, HSVtoRGB(read_imagef(srce, sampler," +
                    " idx)));\n}\n\n\n\r\n\r\n\r\n\nfloat4 RGBtoXYZ(float4 RGB)\n{\n    float r = (RGB.x > 0.04045" +
                    "f)? pow((RGB.x + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.x/12.92f) ;\n    float g = (R" +
                    "GB.y > 0.04045f)? pow((RGB.y + 0.055f)/(1 + 0.055f), 2.2f) : (RGB.y/12.92f) ;\n  " +
                    "  float b = (RGB.z > 0.04045f)? pow((RGB.z + 0.055f)/(1 + 0.055f), 2.2f) : (RGB." +
                    "z/12.92f) ;\n\n    return (float4)((r*0.4124f + g*0.3576f + b*0.1805f),\n          " +
                    "          (r*0.2126f + g*0.7152f + b*0.0722f),\n                    (r*0.0193f + " +
                    "g*0.1192f + b*0.9505f),\n                    RGB.w\n                  );\n}\n\nfloat4" +
                    " XYZtoRGB(float4 XYZ)\n{\n    float4 val;\n    val.x =  XYZ.x*3.2410f - XYZ.y*1.537" +
                    "4f - XYZ.z*0.4986f;\n    val.y = -XYZ.x*0.9692f + XYZ.y*1.8760f - XYZ.z*0.0416f;\n" +
                    "    val.z =  XYZ.x*0.0556f - XYZ.y*0.2040f + XYZ.z*1.0570f;\n\n    val.x = (val.x<" +
                    "=0.0031308f)? 12.92f*val.x : (1.0f+0.055f)* pow(val.x, (1.0f/2.4f)) - 0.055f;\n  " +
                    "  val.y = (val.y<=0.0031308f)? 12.92f*val.y : (1.0f+0.055f)* pow(val.y, (1.0f/2." +
                    "4f)) - 0.055f;\n    val.z = (val.z<=0.0031308f)? 12.92f*val.z : (1.0f+0.055f)* po" +
                    "w(val.z, (1.0f/2.4f)) - 0.055f;\n\n    val.w = XYZ.w;\n    return val;\n}\n\n__kernel " +
                    "void clRGBtoXYZ(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    co" +
                    "nst sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_A" +
                    "DDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    in" +
                    "t2 idx = (int2)(x,y);\n    write_imagef(dest, idx, RGBtoXYZ(read_imagef(srce, sam" +
                    "pler, idx)));\n}\n\n__kernel void clXYZtoRGB(__read_only image2d_t srce,__write_onl" +
                    "y image2d_t dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | " +
                    "CLK_FILTER_NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y " +
                    "= get_global_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, XYZt" +
                    "oRGB(read_imagef(srce, sampler, idx)));\n}\n\n\r\n\r\n\r\n\n\nfloat Ffor(float t)\n{\n    ret" +
                    "urn ((t > 0.008856f)? pow(t, (1.0f/3.0f)) : (7.787f*t + 16.0f/116.0f));\n}\n\nfloat" +
                    "4 RGBtoLAB(float4 RGB)\n{\n    const float4 D65 = (float4)(0.9505f, 1.0f, 1.0890f," +
                    " 0.0f);\n\n    float4 XYZ = RGBtoXYZ(RGB);\n\n    float4 LAB;\n    LAB.x = 116.0f *  " +
                    "Ffor(XYZ.y/D65.y) -16.0f;\n    LAB.y = 500.0f * (Ffor(XYZ.x/D65.x) - Ffor(XYZ.y/D" +
                    "65.y));\n    LAB.z = 200.0f * (Ffor(XYZ.y/D65.y) - Ffor(XYZ.z/D65.z));\n    LAB.w " +
                    "= XYZ.w;\n    return LAB;\n}\n\nfloat4 LABtoRGB(float4 LAB)\n{\n    const float4 D65 =" +
                    " (float4)(0.9505, 1.0, 1.0890, 0.0);\n\n    float fy = (LAB.x+16.0f)/116.0f;\n    f" +
                    "loat fx = fy + (LAB.y/500.0f);\n    float fz = fy - (LAB.z/200.0f);\n\n    float de" +
                    "lta = 6.0/29.0;\n    float4 XYZ = (float4)(\n                (fx > delta)? D65.x *" +
                    " (fx*fx*fx) : (fx - 16.0f/116.0f)*3*(delta*delta)*D65.x,\n                (fy > d" +
                    "elta)? D65.y * (fy*fy*fy) : (fy - 16.0f/116.0f)*3*(delta*delta)*D65.y,\n         " +
                    "       (fz > delta)? D65.z * (fz*fz*fz) : (fz - 16.0f/116.0f)*3*(delta*delta)*D6" +
                    "5.z,\n                 LAB.w);\n\n    return XYZtoRGB(XYZ);\n}\n\n__kernel void clRGBt" +
                    "oLAB(__read_only image2d_t srce,__write_only image2d_t dest)\n{\n    const sampler" +
                    "_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_NEAREST | CLK_ADDRESS_CLAM" +
                    "P;\n    int x = get_global_id(0);\n    int y = get_global_id(1);\n    int2 idx = (i" +
                    "nt2)(x,y);\n    write_imagef(dest, idx, RGBtoLAB(read_imagef(srce, sampler, idx))" +
                    ");\n}\n\n__kernel void clLABtoRGB(__read_only image2d_t srce,__write_only image2d_t" +
                    " dest)\n{\n    const sampler_t sampler = CLK_NORMALIZED_COORDS_FALSE | CLK_FILTER_" +
                    "NEAREST | CLK_ADDRESS_CLAMP;\n    int x = get_global_id(0);\n    int y = get_globa" +
                    "l_id(1);\n    int2 idx = (int2)(x,y);\n    write_imagef(dest, idx, LABtoRGB(read_i" +
                    "magef(srce, sampler, idx)));\n}\n\n\n";
            }
        }

        public string getKernelSource()
        {
          return KernelSource;
        }

        protected override string KernelName {
            get {
                return "clRGBtoLAB";
            }
        }
        
        private OpenCL.Net.Event run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1 = 0, uint globalWorkSize2 = 0, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 0, srce);
            OpenCL.Net.Cl.SetKernelArg(this.Kernel, 1, dest);
            OpenCL.Net.Event ev;
            OpenCL.Net.ErrorCode err;
            err = OpenCL.Net.Cl.EnqueueNDRangeKernel(commandQueue, this.Kernel, base.GetWorkDimension(globalWorkSize0, globalWorkSize1, globalWorkSize2), null, base.GetWorkSizes(globalWorkSize0, globalWorkSize1, globalWorkSize2), base.GetWorkSizes(localWorkSize0, localWorkSize1, localWorkSize2), ((uint)(waitFor.Length)), waitFor.Length == 0 ? null : waitFor, out ev);
            OpenCL.Net.Cl.Check(err);
            return ev;
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize, uint localWorkSize = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize, localWorkSize0: localWorkSize, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint localWorkSize0 = 0, uint localWorkSize1 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, waitFor: waitFor);
        }
        
        public void Run(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            OpenCL.Net.Event ev = this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
            ev.Wait();
        }
        
        public OpenCL.Net.Event EnqueueRun(OpenCL.Net.CommandQueue commandQueue, OpenCL.Net.IMem srce, OpenCL.Net.IMem dest, uint globalWorkSize0, uint globalWorkSize1, uint globalWorkSize2, uint localWorkSize0 = 0, uint localWorkSize1 = 0, uint localWorkSize2 = 0, params OpenCL.Net.Event[] waitFor) {
            return this.run(commandQueue, srce, dest, globalWorkSize0: globalWorkSize0, globalWorkSize1: globalWorkSize1, globalWorkSize2: globalWorkSize2, localWorkSize0: localWorkSize0, localWorkSize1: localWorkSize1, localWorkSize2: localWorkSize2, waitFor: waitFor);
        }
    }*/
}
